{"version":3,"sources":["linkage.js","index.js"],"names":["isPlacementValid","candidate_move","gameboard_state","fields","field","length","isAdjacencySatisfied","previous_move","color","Square","props","colormap","null","style","background","selected_style","border","selected","selected_div","className","onClick","Board","squares","Array","from","fill","state","gameboard","colorpieces","move_stage","selected_color","placement","i","j","more_is_next","winner","game_ended","turn_skipped","this","undefined","setState","slice","JSON","parse","stringify","linkage","possible_moves","m","n","Object","entries","key","push","gameboard_row","group_count","gameboard_visited","tile_stack","num_of_groups","gameboard_tile","group_color","tile_node","pop","console","log","fake_field","resetMoveStage","handleClick","status","gameboard_render","content_row","renderGameboardSquare","renderColorpickerSquare","React","Component","Game","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.c824a6fa.chunk.js","sourcesContent":["/**\n *  @file linkage.js\n *  \n *  @author Stanislav Sotnikov\n * \t\n *  stanislav.sotnikov145@gmail.som\n */\n\nexport function clearCandidateMove(gameboard_state){\n\n    const fake_field = [gameboard_state.length + 2, gameboard_state[0].length + 2]; \n\n    const candidate_move = {\n        fields: [fake_field, fake_field],\n        color: 0,\n    };\n    \n    return candidate_move;\n}\n\n //! explore_possible_moves method.\n/**\n *  @brief Explore all posible moves at the given gameboard_state.\n *  \n *  @param gameboard_state Gameboard state to be checked.\n *  @return possible_moves Vector to store possible moves.\n */\nexport function explorePossibleMoves(gameboard_state, previous_move, colorpieces){\n\n\t// Find all possible ways to attach to a corner of the previous played piece.\n\t// There are 8 possible ways to attach at most we need to find one with more exposed edges.\n\n    var possible_moves = [];\n\tvar i = 0;\n\tvar j = 0;\n\n\tfor(let m=0; m<gameboard_state.length; m++){\n\n\t\tfor(let n=0; n<gameboard_state.length; n++){\n\n\t\t\tvar candidate_move = {\n\n                fields: [[null, null],[null, null]],\n                color: null,\n            };\n            \n\t\t\tcandidate_move.fields[0][0] = i;\n\t\t\tcandidate_move.fields[0][1] = j;\n\t\t\t\n\t\t\t// Check horizontal placement.\n\t\t\tcandidate_move.fields[1][0] = i;\n            candidate_move.fields[1][1] = j + 1;\n\n\t\t\tif(isPlacementValid(candidate_move, gameboard_state) && isAdjacencySatisfied(candidate_move, previous_move)){\n                \n                for(const [key, value] of Object.entries(colorpieces)){\n                    \n                    if(value > 0){\n                        \n                        candidate_move.color = key;\n                        possible_moves.push(candidate_move);\n                    }\n                }\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Check vertical placement.\n\t\t\tcandidate_move.fields[1][0] = i + 1;\n\t\t\tcandidate_move.fields[1][1] = j;\n\n\t\t\tif(isPlacementValid(candidate_move, gameboard_state) && isAdjacencySatisfied(candidate_move, previous_move)){\n\n\t\t\t\tfor(const [key, value] of Object.entries(colorpieces)){\n\n                    if(value > 0){\n                        candidate_move.color = key;\n                        possible_moves.push(candidate_move);\n                    }\n                }\t\t\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tj = 0;\n\t\ti++;\n    }\n    \n    return possible_moves;\n}\n\n//! group_count function.\n/**\n *  @brief Count the number of groups at the given gameboard_state.\n *  @param gameboard_state Gameboard state to be checked.\n *  @return Number of groups.\n */\nexport function groupCount(gameboard_state){\n\n    //std::array<std::array<bool, 7>, 7> gameboard_visited;\n    // Fill gameboard_visited with zeros.\n    var gameboard_visited = Array.from(Array(gameboard_state.length), () => new Array(gameboard_state.length).fill(false));\n\n    //std::stack<std::pair<int, int> > tile_stack;\n    var tile_stack = [];\n\n\tvar i = 0;\n\tvar j = 0;\n\tvar num_of_groups = 0;\n\t\n\t// Depth First Search to count tile groups.\n\tfor(const gameboard_row of gameboard_state){\n\n\t\tfor(const gameboard_tile of gameboard_row){\n\n\t\t\tif(gameboard_visited[i][j] === false && gameboard_tile !== 0 && gameboard_tile !== gameboard_state.length){\n\n\t\t\t\t// Valid piece not counted before.\n\t\t\t\ttile_stack.push([i,j]);\n\n\t\t\t\tconst group_color = gameboard_tile;\n\t\t\t\t\n\t\t\t\t// Found a new group.\n\t\t\t\t++num_of_groups;\n\t\t\t\t\n\t\t\t\twhile(tile_stack.length !== 0){\n\n\t\t\t\t\tconst tile_node = tile_stack.pop();\n\n\t\t\t\t\t// Check tile to the right (next column).\n\t\t\t\t\tif(tile_node[1] < gameboard_row.length - 1){\n\n\t\t\t\t\t\tif(gameboard_state[tile_node[0]][tile_node[1] + 1] === group_color &&\n\t\t\t\t\t\t\tgameboard_visited[tile_node[0]][tile_node[1] + 1] === false)\n\n\t\t\t\t\t\t\ttile_stack.push([tile_node[0], tile_node[1] + 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check tile to the left (previous column).\n\t\t\t\t\tif(tile_node[1] > 0){\n\n\t\t\t\t\t\tif(gameboard_state[tile_node[0]][tile_node[1] - 1] === group_color &&\n\t\t\t\t\t\t\tgameboard_visited[tile_node[0]][tile_node[1] - 1] === false)\n\n\t\t\t\t\t\t\ttile_stack.push([tile_node[0], tile_node[1] - 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check tile below (next row).\n\t\t\t\t\tif(tile_node[0] < gameboard_state.length - 1){\n\n\t\t\t\t\t\tif(gameboard_state[tile_node[0] + 1][tile_node[1]] === group_color &&\n\t\t\t\t\t\t\tgameboard_visited[tile_node[0] + 1][tile_node[1]] === false)\n\n\t\t\t\t\t\t\ttile_stack.push([tile_node[0] + 1, tile_node[1]]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check tile above (previous row).\n\t\t\t\t\tif(tile_node[0] > 0){\n\n\t\t\t\t\t\tif(gameboard_state[tile_node[0] - 1][tile_node[1]] === group_color &&\n\t\t\t\t\t\t\tgameboard_visited[tile_node[0] - 1][tile_node[1]] === false)\n\n\t\t\t\t\t\t\ttile_stack.push([tile_node[0] - 1, tile_node[1]]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Mark tile as visited.\n\t\t\t\t\tgameboard_visited[tile_node[0]][tile_node[1]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++j;\n\t\t}\n\t\tj=0;\n\t\t++i;\n\t}\n\treturn num_of_groups;\n}\n\nexport function isGamEnded(gameboard_state) { \n\t\n\tvar i = 0;\n\tvar j = 0;\n\n\t// Check if there is a possible move for each emty space found in gameboard.\n\tfor(const gameboard_row of gameboard_state){\n        \n\t\tfor(const gameboard_tile of gameboard_row){\n            \n\t\t\tif(gameboard_tile == null){\n\n\t\t\t\t// Found empty space. \n\t\t\t\t// Check if the tiles down && to the right are also empty.\n\t\t\t\tif(i < gameboard_state.length - 1){\n\n\t\t\t\t\tif(gameboard_state[i+1][j] == null){\n                        \n                        return false;\n                    }\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(j < gameboard_row.length - 1){\n\n\t\t\t\t\tif(gameboard_state[i][j+1] == null){\n                        \n                        return false;\n                    }\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t++j;\n\t\t}\n\t\tj=0;\n\t\t++i;\n\t}\n\n\treturn true; \n}\n\n//! is_placement_valid function.\n/**\n *\t@brief\tCheck if a given tile satisfies geometric constraints.\n *\t\t\tDoes not check the adjacency rule.\n *\t@param\tcandidate_move A pair of coordinates [[i,j], [i,j]]\n *\t@param\tgameboard_state State of the gameboard to check against.\n *\t@return True if the move is valid, false otherwise.\n */ \n// Warning: this function does not check for adjacency with the previous move. \nexport function isPlacementValid(candidate_move, gameboard_state){\n\n\t// Check if given fields form a tile.\n\tif(! (((candidate_move.fields[0][0] === candidate_move.fields[1][0] + 1 || \n\t\tcandidate_move.fields[0][0] === candidate_move.fields[1][0] - 1) && \n\t\tcandidate_move.fields[0][1] === candidate_move.fields[1][1]) ||\n\t\t\n\t\t((candidate_move.fields[0][1] === candidate_move.fields[1][1] + 1 || \n\t\tcandidate_move.fields[0][1] === candidate_move.fields[1][1] - 1) && \n\t\tcandidate_move.fields[0][0] === candidate_move.fields[1][0]))){\n\n        //std::cout<<\"Fields don't form a valid tile.\"<<std::endl;\n        return false;\n\t}\n\n    for(const field of candidate_move.fields){\n\n        if(field[0] < 0 || field[0] >= gameboard_state.length ||\n            field[1] < 0 || field[1] >= gameboard_state[0].length){\n            \n            return false;\n        }\n        // Check if the space is empty.\n        if(gameboard_state[field[0]][field[1]] != null){\n            \n            return false;\n        }  \n    }\n\n\treturn true;\n}\n\n//! is_adjacency_satisfied function.\n/**\n *  @brief Checks if the given move satisfies the adjacecy rule.\n *  @param candidate_move Move to be checked.\n *  @param previous_move Move to check adjacency rule against.\n * \t@return True if adjacency is satisfied, flase otherwise.\n */\nexport function isAdjacencySatisfied(candidate_move, previous_move){\n\n    \n    if(previous_move.color == null){\n\n        return true;\n    }\n    for(const field of candidate_move.fields){\n\n        // Check row adjacency for each field.\n\t\tif(((field[0] === previous_move.fields[0][0] + 1 ||\n\t\t\tfield[0] === previous_move.fields[0][0] - 1) && \n\t\t\tfield[1] === previous_move.fields[0][1]) ||\n\n\t\t\t((field[0] === previous_move.fields[1][0] + 1 ||\n\t\t\tfield[0] === previous_move.fields[1][0] - 1) &&\n\t\t\tfield[1] === previous_move.fields[1][1])){\n\n            return false;\n        }\n\n\t\t// Check column adjacency for each field.\n\t\tif(((field[1] === previous_move.fields[0][1] + 1 ||\n\t\t\tfield[1] === previous_move.fields[0][1] - 1) &&\n\t\t\tfield[0] === previous_move.fields[0][0]) ||\n\n\t\t\t((field[1] === previous_move.fields[1][1] + 1 ||\n\t\t\tfield[1] === previous_move.fields[1][1] - 1) &&\n\t\t\tfield[0] === previous_move.fields[1][0])){\n            \n            return false;\n        }\n    }\n\n\treturn true;\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport * as linkage from './linkage.js';\n\nconst board_size = 7;\n\nfunction Square(props){\n\n  const colormap = {\n    null: 'gainsboro',\n    'C': 'grey',\n    'W': 'white',\n    'Y': 'yellow',\n    'R': 'red',\n    'B': 'blue',\n    'X': 'black',\n    'O': 'white',\n  };\n\n  const style = {\n    background: colormap[props.color],\n  }\n\n  const selected_style = {\n    border: (props.selected != null) ? '2px solid ' + colormap[props.selected] : '2px solid transparent',\n  }\n\n  const selected_div = (<div className=\"selected-square\" style={selected_style}></div>);\n\n  return (<button className=\"square\" onClick={props.onClick} style={style} >{selected_div}</button>);\n\n}\n\nclass Board extends React.Component {\n\n  constructor(props){\n    super(props);\n\n    var squares = Array.from(Array(board_size), () => new Array(board_size).fill(null));\n    squares[(board_size - 1)/2][(board_size - 1)/2] = 'C';\n\n    this.state = {\n      gameboard: squares,\n      colorpieces: {\n        'W': 6,\n        'Y': 6,\n        'R': 6,\n        'B': 6,\n      },\n      move_stage: {\n        selected_color: null,\n        placement: {\n            i: null,\n            j: null,\n          }, \n      },\n      previous_move: {\n        fields: [[null, null],[null, null]],\n        color: null,\n      },\n      more_is_next: true,\n      winner: null,\n      game_ended: false,\n      turn_skipped: false,\n    };\n  }\n\n  // Click on gameboard or colorpicker.\n  handleClick(i, j){\n\n    if(this.state.winner == null && j !== undefined){\n\n      if(this.state.gameboard[i][j] === 'C'){\n        // Do nothing if the blocked tile is clicked.\n        return;\n      }\n      // Check if clicked space is empty.\n      if(this.state.gameboard[i][j] == null){\n\n        if(this.state.move_stage.placement.i == null){\n          this.setState({\n            move_stage: {\n              selected_color: this.state.move_stage.selected_color,\n              placement: {\n                i: i,\n                j: j,\n              },\n            },\n          }); \n        }\n        else{\n          \n          const squares = this.state.gameboard.slice();\n\n          // puke\n          var candidate_move = JSON.parse(JSON.stringify(this.state.previous_move));\n          const previous_move = JSON.parse(JSON.stringify(this.state.previous_move));\n\n          candidate_move.fields = [[this.state.move_stage.placement.i, this.state.move_stage.placement.j], [i, j]];\n          candidate_move.color = this.state.move_stage.selected_color;\n\n          if(linkage.isPlacementValid(candidate_move, squares) && linkage.isAdjacencySatisfied(candidate_move, previous_move)){\n\n            squares[this.state.move_stage.placement.i][this.state.move_stage.placement.j] = this.state.move_stage.selected_color;\n            squares[i][j] = this.state.move_stage.selected_color;\n            \n            const colorpieces = this.state.colorpieces;\n            colorpieces[this.state.move_stage.selected_color] -= 1;\n\n            // candidate move is the previous move in the following function call.\n            const possible_moves = linkage.explorePossibleMoves(squares, candidate_move, this.state.colorpieces);\n\n            const game_ended = linkage.isGamEnded(squares);\n            var turn_skipped = false;\n            var winner = null;\n\n            if(!game_ended && possible_moves === 0){\n\n              // Clear candidate move\n              candidate_move = linkage.clearCandidateMove(squares);\n\n              turn_skipped = true;\n            }\n            else if(game_ended){\n\n              const group_count = linkage.groupCount(squares);\n              winner = (group_count < 12) ? 'Less' : 'More';\n              console.log('The winner is: ' + winner);\n              console.log('Group count: ' + group_count);\n            }\n\n            console.log('Found ' + possible_moves.length + ' possible moves!');\n            // Register a move.\n            this.setState({\n              gameboard: squares,\n              colorpieces: colorpieces,\n              more_is_next: turn_skipped ? this.state.more_is_next : !this.state.more_is_next,\n              previous_move: candidate_move,\n              turn_skipped: turn_skipped,\n              game_ended: game_ended,\n              winner: winner,\n            });\n          }\n          else{\n\n            console.log('Placement invalid!');\n          }\n          this.resetMoveStage();\n        }\n      }\n    }\n    // Colorpicker clicked.\n    else if(j === undefined && this.state.colorpieces[i] > 0){\n        \n      this.setState({\n        move_stage: {\n          selected_color: i,\n          placement: {\n              i: null,\n              j: null,\n            }, \n        },\n      });\n    }\n  }\n\n  resetMoveStage(){\n    this.setState({\n      move_stage: {\n        selected_color: null,\n        placement: {\n            i: null,\n            j: null,\n          }, \n      },\n    });\n  }\n  renderSquare(selected, i, j) {\n\n    // Click on the colorpicker: @param i represents color.\n    // Click on the gameboard: @param i, j represent location.\n    const color = (j === undefined) ? i : this.state.gameboard[i][j];\n\n    return (\n      <Square \n        color={color}\n        selected={selected}\n        onClick={() => this.handleClick(i, j)}\n      />\n    );\n  }\n  renderColorpickerSquare(color){\n\n    return (\n      <Square \n        color={color}\n        selected={(this.state.move_stage.selected_color == color) ? 'X' : null}\n        onClick={() => this.handleClick(color)}\n      />\n    );\n  }\n\n  renderGameboardSquare(i, j){\n\n    // Click on the colorpicker: @param i represents color.\n    // Click on the gameboard: @param i, j represent location.\n    var selected = null;\n\n    if(this.state.move_stage.placement.i == i && this.state.move_stage.placement.j == j){\n\n      selected = this.state.move_stage.selected_color;\n    }\n\n    return (\n      <Square \n        color={this.state.gameboard[i][j]}\n        selected={selected}\n        onClick={() => this.handleClick(i, j)}\n      />\n    );\n  }\n\n\n  render() {\n\n    let status = \"\";\n\n    if(this.state.winner == null){\n\n      if(this.state.turn_skipped){\n\n        status = 'Player ' + (this.state.more_is_next ? 'More' : 'Less') + ' goes again!';\n      }\n      else{\n\n        status = 'Next Player: ' + (this.state.more_is_next ? 'More' : 'Less');\n      }\n    }\n    else{\n\n      status = 'Player ' + this.state.winner + ' wins!';\n    }\n\n    var gameboard_render = [];\n    for(let i=0; i<board_size; i++){\n      \n      var content_row = [];\n      for(let j=0; j<board_size; j++){\n\n        content_row.push(this.renderGameboardSquare(i,j));\n      }\n\n      gameboard_render.push(<div className=\"board-row\">{content_row}</div>)\n    }\n\n    return (\n      <div>\n        <div className=\"status\">{status}</div>\n        <div className=\"game-board\">{gameboard_render}</div>\n        \n        <div className=\"colorpicker\">\n          {this.state.colorpieces['Y'] ? this.renderColorpickerSquare('Y') : this.renderColorpickerSquare('C')}\n          {this.state.colorpieces['Y'] ? this.renderColorpickerSquare('Y') : this.renderColorpickerSquare('C')}\n        </div>\n        <div className=\"colorpicker\">\n          {this.state.colorpieces['W'] ? this.renderColorpickerSquare('W') : this.renderColorpickerSquare('C')}\n          {this.state.colorpieces['W'] ? this.renderColorpickerSquare('W') : this.renderColorpickerSquare('C')}\n        </div>\n        <div className=\"colorpicker\">\n          {this.state.colorpieces['R'] ? this.renderColorpickerSquare('R') : this.renderColorpickerSquare('C')}\n          {this.state.colorpieces['R'] ? this.renderColorpickerSquare('R') : this.renderColorpickerSquare('C')}\n        </div>\n        <div className=\"colorpicker\">\n        {this.state.colorpieces['B'] ? this.renderColorpickerSquare('B') : this.renderColorpickerSquare('C')}\n          {this.state.colorpieces['B'] ? this.renderColorpickerSquare('B') : this.renderColorpickerSquare('C')}\n        </div>\n      </div>\n    );\n  }\n}\n\nclass Game extends React.Component {\n  render() {\n    return (\n      <div className=\"game\">\n          <Board />\n      </div>\n    );\n  }\n}\n\n// ========================================\n\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}