{"version":3,"sources":["linkage.js","index.js"],"names":["clearCandidateMove","gameboard_state","fake_field","length","fields","color","explorePossibleMoves","previous_move","colorpieces","possible_moves","i","j","m","n","candidate_move","isPlacementValid","isAdjacencySatisfied","Object","entries","key","push","JSON","parse","stringify","groupCount","gameboard_visited","Array","from","fill","tile_stack","num_of_groups","gameboard_row","gameboard_tile","group_color","tile_node","pop","isGamEnded","field","computerMove","side","valid_candidate_moves","candidate_moves","computer_side","gameboard_projection","placeOnGameboard","rank","groups_after_candidate_move","further_moves","further_candidate_move","groupforming_options","further_move","gameboard_projection_2","rankValidMoves","optimal_rank","min","max","optimal_moves","Math","ceil","floor","random","move","gameboard","Square","props","colormap","null","style","background","selected_style","border","selected","selected_div","className","onClick","Board","squares","state","move_stage","selected_color","placement","more_is_next","game_mode","winner","turn_skipped","player_skips","computer_skips","this","undefined","setState","linkage","playerMove","console","log","resetMoveStage","handleClick","bold","normal","disabled","is_single_player","handleChange","event","target","name","checked","computerMoveRecursive","Switch","onChange","game_state","game_ended","computer_move","group_count","player_move","status","groups","gameboard_render","content_row","renderGameboardSquare","renderColorpickerSquare","renderGameModeSwitches","React","Component","Game","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.82e7f996.chunk.js","sourcesContent":["/**\n *  @file linkage.js\n *  \n *  @author Stanislav Sotnikov\n * \t\n *  stanislav.sotnikov145@gmail.som\n */\n\nexport function clearCandidateMove(gameboard_state){\n\n    const fake_field = [gameboard_state.length + 2, gameboard_state[0].length + 2]; \n\n    const candidate_move = {\n        fields: [fake_field, fake_field],\n        color: 0,\n    };\n    \n    return candidate_move;\n}\n\n //! explore_possible_moves method.\n/**\n *  @brief Explore all posible moves at the given gameboard_state.\n *  \n *  @param gameboard_state Gameboard state to be checked.\n *  @return possible_moves Vector to store possible moves.\n */\nexport function explorePossibleMoves(gameboard_state, previous_move, colorpieces){\n\n\t// Find all possible ways to attach to a corner of the previous played piece.\n\t// There are 8 possible ways to attach at most we need to find one with more exposed edges.\n\n    var possible_moves = [];\n\tvar i = 0;\n\tvar j = 0;\n\n\tfor(let m=0; m<gameboard_state.length; m++){\n\n\t\tfor(let n=0; n<gameboard_state.length; n++){\n\n\t\t\tvar candidate_move = {\n\n                fields: [[null, null],[null, null]],\n                color: null,\n            };\n            \n\t\t\tcandidate_move.fields[0][0] = i;\n\t\t\tcandidate_move.fields[0][1] = j;\n\t\t\t\n\t\t\t// Check horizontal placement.\n\t\t\tcandidate_move.fields[1][0] = i;\n            candidate_move.fields[1][1] = j + 1;\n\n\t\t\tif(isPlacementValid(candidate_move, gameboard_state) && isAdjacencySatisfied(candidate_move, previous_move)){\n                \n                for(const [key, value] of Object.entries(colorpieces)){\n                    \n                    if(value > 0){\n                        \n                        candidate_move.color = key;\n                        possible_moves.push(JSON.parse(JSON.stringify(candidate_move)));\n                    }\n                }\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Check vertical placement.\n\t\t\tcandidate_move.fields[1][0] = i + 1;\n\t\t\tcandidate_move.fields[1][1] = j;\n\n\t\t\tif(isPlacementValid(candidate_move, gameboard_state) && isAdjacencySatisfied(candidate_move, previous_move)){\n\n\t\t\t\tfor(const [key, value] of Object.entries(colorpieces)){\n\n                    if(value > 0){\n                        candidate_move.color = key;\n                        possible_moves.push(JSON.parse(JSON.stringify(candidate_move)));\n                    }\n                }\t\t\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tj = 0;\n\t\ti++;\n    }\n    \n    return possible_moves;\n}\n\n// Get Pseudo random integer between two numbers.\nfunction getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\n}\n\n//! group_count function.\n/**\n *  @brief Count the number of groups at the given gameboard_state.\n *  @param gameboard_state Gameboard state to be checked.\n *  @return Number of groups.\n */\nexport function groupCount(gameboard_state){\n\n    //std::array<std::array<bool, 7>, 7> gameboard_visited;\n    // Fill gameboard_visited with zeros.\n    var gameboard_visited = Array.from(Array(gameboard_state.length), () => new Array(gameboard_state.length).fill(false));\n\n    //std::stack<std::pair<int, int> > tile_stack;\n    var tile_stack = [];\n\n\tvar i = 0;\n\tvar j = 0;\n\tvar num_of_groups = 0;\n\t\n\t// Depth First Search to count tile groups.\n\tfor(const gameboard_row of gameboard_state){\n\n\t\tfor(const gameboard_tile of gameboard_row){\n\n\t\t\tif(gameboard_visited[i][j] === false && gameboard_tile !== null && gameboard_tile !== gameboard_state.length){\n\n\t\t\t\t// Valid piece not counted before.\n\t\t\t\ttile_stack.push([i,j]);\n\n\t\t\t\tconst group_color = gameboard_tile;\n\t\t\t\t\n\t\t\t\t// Found a new group.\n\t\t\t\t++num_of_groups;\n\t\t\t\t\n\t\t\t\twhile(tile_stack.length !== 0){\n\n\t\t\t\t\tconst tile_node = tile_stack.pop();\n\n\t\t\t\t\t// Check tile to the right (next column).\n\t\t\t\t\tif(tile_node[1] < gameboard_row.length - 1){\n\n\t\t\t\t\t\tif(gameboard_state[tile_node[0]][tile_node[1] + 1] === group_color &&\n\t\t\t\t\t\t\tgameboard_visited[tile_node[0]][tile_node[1] + 1] === false)\n\n\t\t\t\t\t\t\ttile_stack.push([tile_node[0], tile_node[1] + 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check tile to the left (previous column).\n\t\t\t\t\tif(tile_node[1] > 0){\n\n\t\t\t\t\t\tif(gameboard_state[tile_node[0]][tile_node[1] - 1] === group_color &&\n\t\t\t\t\t\t\tgameboard_visited[tile_node[0]][tile_node[1] - 1] === false)\n\n\t\t\t\t\t\t\ttile_stack.push([tile_node[0], tile_node[1] - 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check tile below (next row).\n\t\t\t\t\tif(tile_node[0] < gameboard_state.length - 1){\n\n\t\t\t\t\t\tif(gameboard_state[tile_node[0] + 1][tile_node[1]] === group_color &&\n\t\t\t\t\t\t\tgameboard_visited[tile_node[0] + 1][tile_node[1]] === false)\n\n\t\t\t\t\t\t\ttile_stack.push([tile_node[0] + 1, tile_node[1]]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check tile above (previous row).\n\t\t\t\t\tif(tile_node[0] > 0){\n\n\t\t\t\t\t\tif(gameboard_state[tile_node[0] - 1][tile_node[1]] === group_color &&\n\t\t\t\t\t\t\tgameboard_visited[tile_node[0] - 1][tile_node[1]] === false)\n\n\t\t\t\t\t\t\ttile_stack.push([tile_node[0] - 1, tile_node[1]]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Mark tile as visited.\n\t\t\t\t\tgameboard_visited[tile_node[0]][tile_node[1]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++j;\n\t\t}\n\t\tj=0;\n\t\t++i;\n\t}\n\treturn num_of_groups - 1; //Center tile will count as a group.\n}\n\nexport function isGamEnded(gameboard_state) { \n\t\n\tvar i = 0;\n\tvar j = 0;\n\n\t// Check if there is a possible move for each emty space found in gameboard.\n\tfor(const gameboard_row of gameboard_state){\n        \n\t\tfor(const gameboard_tile of gameboard_row){\n            \n\t\t\tif(gameboard_tile == null){\n\n\t\t\t\t// Found empty space. \n\t\t\t\t// Check if the tiles down && to the right are also empty.\n\t\t\t\tif(i < gameboard_state.length - 1){\n\n\t\t\t\t\tif(gameboard_state[i+1][j] == null){\n                        \n                        return false;\n                    }\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(j < gameboard_row.length - 1){\n\n\t\t\t\t\tif(gameboard_state[i][j+1] == null){\n                        \n                        return false;\n                    }\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t++j;\n\t\t}\n\t\tj=0;\n\t\t++i;\n\t}\n\n\treturn true; \n}\n\n//! is_placement_valid function.\n/**\n *\t@brief\tCheck if a given tile satisfies geometric constraints.\n *\t\t\tDoes not check the adjacency rule.\n *\t@param\tcandidate_move A pair of coordinates [[i,j], [i,j]]\n *\t@param\tgameboard_state State of the gameboard to check against.\n *\t@return True if the move is valid, false otherwise.\n */ \n// Warning: this function does not check for adjacency with the previous move. \nexport function isPlacementValid(candidate_move, gameboard_state){\n\n\t// Check if given fields form a tile.\n\tif(! (((candidate_move.fields[0][0] === candidate_move.fields[1][0] + 1 || \n\t\tcandidate_move.fields[0][0] === candidate_move.fields[1][0] - 1) && \n\t\tcandidate_move.fields[0][1] === candidate_move.fields[1][1]) ||\n\t\t\n\t\t((candidate_move.fields[0][1] === candidate_move.fields[1][1] + 1 || \n\t\tcandidate_move.fields[0][1] === candidate_move.fields[1][1] - 1) && \n\t\tcandidate_move.fields[0][0] === candidate_move.fields[1][0]))){\n\n        //std::cout<<\"Fields don't form a valid tile.\"<<std::endl;\n        return false;\n\t}\n\n    for(const field of candidate_move.fields){\n\n        if(field[0] < 0 || field[0] >= gameboard_state.length ||\n            field[1] < 0 || field[1] >= gameboard_state.length){\n            \n            return false;\n        }\n        // Check if the space is empty.\n        if(gameboard_state[field[0]][field[1]] != null){\n            \n            return false;\n        }  \n    }\n\n\treturn true;\n}\nexport function computerMove(side, gameboard_state, previous_move, colorpieces) {\n    \n\tvar valid_candidate_moves = explorePossibleMoves(gameboard_state, previous_move, colorpieces);\n\n    rankValidMoves(valid_candidate_moves, gameboard_state, colorpieces, 'More');\n\t\n\tif(valid_candidate_moves.length === 0){\n\t\t//std::cout<<\"Computer skips a turn!\"<<std::endl;\n        //clear_previous_move();\n        return null;\n\t}\n\t\n    // Find moves with minimum rank.\n    var optimal_rank = valid_candidate_moves[0].rank;\n\n    for(const candidate_move of valid_candidate_moves){\n        \n        if(side === 'More' && candidate_move.rank > optimal_rank){\n\n            optimal_rank = candidate_move.rank;\n        }\n        else if(side === 'Less' && candidate_move.rank < optimal_rank){\n\n            optimal_rank = candidate_move.rank;\n        }     \n    }\n\n    // Pick moves with minimum rank.\n    var optimal_moves = [];\n\n    for(const candidate_move of valid_candidate_moves){\n\n        if(candidate_move.rank === optimal_rank)\n            optimal_moves.push(JSON.parse(JSON.stringify(candidate_move)));\n    }\n\n    return optimal_moves[getRandomInt(0, optimal_moves.length)];\n\n} /* needs to be written */\n\n//! is_adjacency_satisfied function.\n/**\n *  @brief Checks if the given move satisfies the adjacecy rule.\n *  @param candidate_move Move to be checked.\n *  @param previous_move Move to check adjacency rule against.\n * \t@return True if adjacency is satisfied, flase otherwise.\n */\nexport function isAdjacencySatisfied(candidate_move, previous_move){\n\n    \n    if(previous_move.color == null){\n\n        return true;\n    }\n    for(const field of candidate_move.fields){\n\n        // Check row adjacency for each field.\n\t\tif(((field[0] === previous_move.fields[0][0] + 1 ||\n\t\t\tfield[0] === previous_move.fields[0][0] - 1) && \n\t\t\tfield[1] === previous_move.fields[0][1]) ||\n\n\t\t\t((field[0] === previous_move.fields[1][0] + 1 ||\n\t\t\tfield[0] === previous_move.fields[1][0] - 1) &&\n\t\t\tfield[1] === previous_move.fields[1][1])){\n\n            return false;\n        }\n\n\t\t// Check column adjacency for each field.\n\t\tif(((field[1] === previous_move.fields[0][1] + 1 ||\n\t\t\tfield[1] === previous_move.fields[0][1] - 1) &&\n\t\t\tfield[0] === previous_move.fields[0][0]) ||\n\n\t\t\t((field[1] === previous_move.fields[1][1] + 1 ||\n\t\t\tfield[1] === previous_move.fields[1][1] - 1) &&\n\t\t\tfield[0] === previous_move.fields[1][0])){\n            \n            return false;\n        }\n    }\n\n\treturn true;\n}\n\n//! place_on_gameboard method.\n/**\n *  @brief Places a move on the given &gameboard. Does not check if the move is valid.\n *  @param move Move to be placed.\n *  @param gameboard Gameboard to place the move.\n */\nexport function placeOnGameboard(move, gameboard){\n\n\tgameboard[move.fields[0][0]][move.fields[0][1]] = move.color;\n\tgameboard[move.fields[1][0]][move.fields[1][1]] = move.color;\n}\n\n//! rank_valid_moves method\n/**\n *  @brief Assign rank to each given move.\n *  @param candidate_moves VALID moves to rank.\n */\nexport function rankValidMoves(candidate_moves, gameboard_state, colorpieces, computer_side){\n\n\tfor(var candidate_move of candidate_moves){\n\n\t\t// Copy current gameboard state.\n\t\tvar gameboard_projection = JSON.parse(JSON.stringify(gameboard_state));\n\n\t\t// Make the candidate move on the projected gameboard.\n\t\tplaceOnGameboard(candidate_move, gameboard_projection);\n\t\t\n\t\t// Calculate the amount of possible moves of the next ply.\n\t\t\n\t\tcandidate_move.rank = 0.01 * explorePossibleMoves(gameboard_projection, candidate_move, colorpieces).length;\n\t\t//candidate_move.rank = std::roundf(candidate_move.rank*10)/10; // Ads non linear randomness and hides a bug=)\n\t\t// Find number of groups on the projected gameboard.\n\t\tconst groups_after_candidate_move = groupCount(gameboard_projection);\n\t\t//std::cout<<groups_after_candidate_move<<std::endl;\n\t\tcandidate_move.rank += 20.0 * groups_after_candidate_move;\n\n\t\t// Fight for the last piece!\n\t\tif(colorpieces[candidate_move.color] === 1){\n\n\t\t\tif(computer_side === 'More')\n\t\t\t\tcandidate_move.rank += 10;\n\t\t\telse\n\t\t\t\tcandidate_move.rank -=10;\n\t\t}\n\t\t\n\t\t// Let's check if we can connect the tiles in the further move.\n\t\t// Only makes sense to explore further moves if there are 2+ pieces available.\n\t\tif(colorpieces[candidate_move.color] > 2){\n\n\t\t\tvar further_moves = [];\n\t\t\t\n\t\t\tvar i = 0;\n            var j = 0;\n\t\t\t\n\t\t\tfor(let m=0; m<gameboard_state.length; m++){\n\n                for(let n=0; n<gameboard_state.length; n++){\n\n                    var further_candidate_move = JSON.parse(JSON.stringify(clearCandidateMove(gameboard_projection)));\n\n\t\t\t\t\tfurther_candidate_move.color = candidate_move.color;\n\t\t\t\t\tfurther_candidate_move.fields[0][0] = i;\n\t\t\t\t\tfurther_candidate_move.fields[0][1] = j;\n\t\t\t\t\t\n\t\t\t\t\t// Check horizontal placement.\n\t\t\t\t\tfurther_candidate_move.fields[1][0] = i;\n\t\t\t\t\tfurther_candidate_move.fields[1][1] = j + 1;\n\n                    // Do not check for adjacency here.\n\t\t\t\t\tif(isPlacementValid(further_candidate_move, gameboard_projection)){\n                        \n                        further_moves.push(JSON.parse(JSON.stringify(further_candidate_move)));\n                    }\n\n\t\t\t\t\t// Check vertical placement.\n\t\t\t\t\tfurther_candidate_move.fields[1][0] = i + 1;\n\t\t\t\t\tfurther_candidate_move.fields[1][1] = j;\n\n\t\t\t\t\t// Do not check for adjacency here.\n\t\t\t\t\tif(isPlacementValid(further_candidate_move, gameboard_projection)){\n\n                        further_moves.push(JSON.parse(JSON.stringify(further_candidate_move)));\n                    }\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tj = 0;\n\t\t\t\ti++;\n            }\n            \n\t\t\t// Find options of the candidate move to make more ways for group creation -- group forming moves.\t\n\t\t\tvar groupforming_options = 0;\n            \n\t\t\t//For each of the further moves find if any new groups can be formed.\n\t\t\tfor(const further_move of further_moves){\n                \n\t\t\t\tvar gameboard_projection_2 = JSON.parse(JSON.stringify(gameboard_projection));\n                \n\t\t\t\tplaceOnGameboard(further_move, gameboard_projection_2);\n\t\t\t\t\n\t\t\t\t// Count how many new groups can be formed.\n\t\t\t\tif(groupCount(gameboard_projection_2) < groups_after_candidate_move){\n                    ++groupforming_options;\n                }\n                gameboard_projection_2 = null;\n\t\t\t}\n\t\t\t//candidate_move.rank += num_of_possible_moves(gameboard_projection_2, further_move);\n\t\t\t\n\t\t\t// Modify candidate move accordingly\n\t\t\tcandidate_move.rank -= 5.0 * groupforming_options;\n\t\t}\n\t}\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Switch from '@material-ui/core/Switch';\n\nimport './index.css';\nimport * as linkage from './linkage.js';\n\nconst board_size = 7;\n\nfunction Square(props){\n\n  const colormap = {\n    null: 'gainsboro',\n    'C': 'grey',\n    'W': 'white',\n    'Y': 'yellow',\n    'R': 'red',\n    'B': 'blue',\n    'X': 'black',\n    'O': 'white',\n  };\n\n  const style = {\n    background: colormap[props.color],\n  }\n\n  const selected_style = {\n    border: (props.selected != null) ? '2px solid ' + colormap[props.selected] : '2px solid transparent',\n  }\n\n  const selected_div = (<div className=\"selected-square\" style={selected_style}></div>);\n\n  return (<button className=\"square\" onClick={props.onClick} style={style} >{selected_div}</button>);\n\n}\n\nclass Board extends React.Component {\n\n  constructor(props){\n    super(props);\n\n    var squares = Array.from(Array(board_size), () => new Array(board_size).fill(null));\n    squares[(board_size - 1)/2][(board_size - 1)/2] = 'C';\n\n    this.state = {\n      gameboard: squares,\n      colorpieces: {\n        'W': 6,\n        'Y': 6,\n        'R': 6,\n        'B': 6,\n      },\n      move_stage: {\n        selected_color: null,\n        placement: {\n            i: null,\n            j: null,\n          }, \n      },\n      previous_move: {\n        fields: [[null, null],[null, null]],\n        color: null,\n      },\n      more_is_next: true,\n      game_mode: false, // is_single_player\n      computer_side: false, // is_computer_playing_for_more\n      winner: null,\n      turn_skipped: false,\n      player_skips: false,\n      computer_skips: false,\n    };\n  }\n\n  // Click on the colorpicker: @param i represents color.\n  // Click on the gameboard: @param i, j represent location.\n  handleClick(i, j){\n\n    if(this.state.winner == null && j !== undefined){\n\n      if(this.state.gameboard[i][j] === 'C'){\n        // Do nothing if the blocked tile is clicked.\n        return;\n      }\n      // Check if clicked space is empty.\n      if(this.state.gameboard[i][j] == null){\n\n        if(this.state.move_stage.placement.i == null){\n          this.setState({\n            move_stage: {\n              selected_color: this.state.move_stage.selected_color,\n              placement: {\n                i: i,\n                j: j,\n              },\n            },\n          }); \n        }\n        else{\n          \n          // puke\n          var candidate_move = JSON.parse(JSON.stringify(this.state.previous_move));\n          const previous_move = JSON.parse(JSON.stringify(this.state.previous_move));\n\n          candidate_move.fields = [[this.state.move_stage.placement.i, this.state.move_stage.placement.j], [i, j]];\n          candidate_move.color = this.state.move_stage.selected_color;\n\n          if(linkage.isPlacementValid(candidate_move, this.state.gameboard) && linkage.isAdjacencySatisfied(candidate_move, previous_move)){\n\n            this.playerMove(candidate_move);\n          }\n          else{\n\n            console.log('Placement invalid!');\n          }\n          this.resetMoveStage();\n        }\n      }\n    }\n    // Colorpicker clicked.\n    else if(j === undefined && this.state.colorpieces[i] > 0){\n        \n      this.setState({\n        move_stage: {\n          selected_color: i,\n          placement: {\n              i: null,\n              j: null,\n            }, \n        },\n      });\n    }\n  }\n\n  resetMoveStage(){\n    this.setState({\n      move_stage: {\n        selected_color: null,\n        placement: {\n            i: null,\n            j: null,\n          }, \n      },\n    });\n  }\n  renderColorpickerSquare(color){\n\n    return (\n      <Square \n        color={color}\n        selected={(this.state.move_stage.selected_color === color) ? 'X' : null}\n        onClick={() => this.handleClick(color)}\n      />\n    );\n  }\n  renderGameModeSwitches(){\n\n    const bold = {\n      'font-weight': 'bold',\n      'color': 'black',\n    }\n    const normal = {\n      'font-weight': 'normal',\n      'color': 'black',\n    }\n    const disabled = {\n      'font-weight': 'normal',\n      'color': 'grey',\n    }\n    const is_single_player = this.state.game_mode;\n    const computer_side = this.state.computer_side ? 'More' : 'Less';\n    \n      \n    const handleChange = (event) => {\n      \n      this.setState({\n        [event.target.name]: event.target.checked,\n        move_stage: {\n          selected_color: null,\n          placement: {\n              i: null,\n              j: null,\n            },\n        },\n      });\n\n      // Figure out if Computer must make a move.\n      if(event.target.name === 'game_mode'){\n\n        if(event.target.checked){\n\n          // Force change the state. Does not affect the UI.\n          this.state.game_mode = true;\n          if(!((computer_side === 'More') !== this.state.more_is_next)){\n            // Make More move\n            this.computerMoveRecursive(JSON.parse(JSON.stringify(this.state)));\n          }\n        }\n        else{\n          this.state.game_mode = false;\n        }\n      }\n      else if(event.target.name === 'computer_side'){\n\n        this.state.computer_side = event.target.checked;\n        \n        if(!(event.target.checked !== this.state.more_is_next)){\n\n          this.computerMoveRecursive(JSON.parse(JSON.stringify(this.state)));\n        }\n      }\n    };\n\n    return (\n      <div className=\"switch-box\">\n\n        <div className=\"game-mode\" className=\"game-mode-left\">\n          <p className=\"game-mode\" style={is_single_player ? normal : bold}>Two Player</p>\n            <Switch name=\"game_mode\" disabled={this.state.winner != null} color=\"grey\" onChange={handleChange}/>\n          <p className=\"game-mode\" style={is_single_player ? bold : normal}>Single Player</p>\n        </div>\n\n        <div className=\"game-mode\" className=\"game-mode-right\">\n          <p className=\"game-mode\" style={is_single_player ? (computer_side === 'Less' ? bold : normal) : disabled}>More</p>\n            <Switch name=\"computer_side\" disabled={!is_single_player || this.state.winner != null} color=\"grey\" onChange={handleChange} />\n          <p className=\"game-mode\" style={is_single_player ? (computer_side === 'More' ? bold : normal) : disabled}>Less</p>\n        </div>\n      </div>\n    );\n  }\n\n  computerMoveRecursive(game_state){\n\n    // Sainity check.\n    if(!this.state.game_mode){\n      return null;\n    }\n    // Copy entire gameboard state\n    const computer_side = this.state.computer_side ? 'More' : 'Less';\n\n    var more_is_next = game_state.more_is_next;\n    var game_ended = false;\n\n    while(more_is_next === game_state.more_is_next && !game_ended){\n\n      console.log('Hello');\n      // Find a move\n      var computer_move = linkage.computerMove(computer_side, game_state.gameboard, game_state.previous_move, game_state.colorpieces);\n\n      // Place the move on the copied gameboard state.\n      linkage.placeOnGameboard(computer_move, game_state.gameboard);\n\n      // Adjust quantity of the colorpieces.\n      game_state.colorpieces[computer_move.color] -= 1;\n\n      // Check if there are moves left and if the game is ended.\n      const possible_moves = linkage.explorePossibleMoves(game_state.gameboard, computer_move, game_state.colorpieces);\n      game_ended = linkage.isGamEnded(game_state.gameboard);\n\n      if(!game_ended && possible_moves.length === 0){\n\n        game_state.previous_move = linkage.clearCandidateMove(game_state.gameboard);\n        game_state.player_skips = true;\n      }\n      else if(game_ended){\n\n        const group_count = linkage.groupCount(game_state.gameboard);\n        game_state.winner = (group_count < 12) ? 'Less' : 'More';\n      }\n      else{\n        \n        game_state.more_is_next = !game_state.more_is_next;\n        game_state.previous_move = computer_move;\n      }\n\n      this.setState(game_state); \n    }\n  }\n\n  playerMove(player_move){\n\n    var game_state = JSON.parse(JSON.stringify(this.state));\n\n    game_state.player_skips = false;\n\n    linkage.placeOnGameboard(player_move, game_state.gameboard);\n\n    // Adjust quantity of the colorpieces.\n    game_state.colorpieces[player_move.color] -= 1;\n\n    // Check if there are moves left and if the game is ended.\n    const possible_moves = linkage.explorePossibleMoves(game_state.gameboard, player_move, game_state.colorpieces);\n    var game_ended = linkage.isGamEnded(game_state.gameboard);\n\n    if(!game_ended && possible_moves.length === 0){\n\n      game_state.previous_move = linkage.clearCandidateMove(game_state.gameboard);\n      game_state.computer_skips = game_state.game_mode; // Computer skips if single player mode\n    }\n    else if(game_ended){\n\n      const group_count = linkage.groupCount(game_state.gameboard);\n      game_state.winner = (group_count < 12) ? 'Less' : 'More';\n    }\n    else{\n        \n      game_state.more_is_next = !game_state.more_is_next;\n      game_state.previous_move = player_move;\n\n      if(game_state.game_mode){\n\n        this.computerMoveRecursive(game_state);\n      }\n    }\n    this.setState(game_state); \n  }\n\n  renderGameboardSquare(i, j){\n\n    // Click on the colorpicker: @param i represents color.\n    // Click on the gameboard: @param i, j represent location.\n    var selected = null;\n\n    if(this.state.move_stage.placement.i === i && this.state.move_stage.placement.j === j){\n\n      selected = this.state.move_stage.selected_color;\n    }\n\n    return (\n      <Square \n        color={this.state.gameboard[i][j]}\n        selected={selected}\n        onClick={() => this.handleClick(i, j)}\n      />\n    );\n  }\n\n  render() {\n\n    let status = \"\";\n    \n    const is_single_player = this.state.game_mode;\n    const computer_side = this.state.computer_side ? 'More' : 'Less';\n\n    if(this.state.winner == null){\n\n      if(!is_single_player){\n\n        if(this.state.turn_skipped){\n\n          status = 'Player ' + (this.state.more_is_next ? 'More' : 'Less') + ' goes again!';\n        }\n        else{\n  \n          status = 'Next Player: ' + (this.state.more_is_next ? 'More' : 'Less');\n        }\n      }\n      else{\n        status = \"Computer plays for \" + computer_side + \". \";\n\n        if(this.state.computer_skips){\n\n          status += \"Player goes again!\"\n        }\n        if(this.state.player_skips){\n\n          status += \"Player skips a turn(s).\"\n        }\n      }\n      \n    }\n    else{\n\n      const groups = linkage.groupCount(this.state.gameboard);\n\n      if(!is_single_player){\n        status = 'Player ' + this.state.winner + ' wins! ';\n      }\n      else{\n\n        if(groups < 12){\n          if(computer_side === 'Less'){\n            status = 'Computer wins for Less! ';\n          }\n          else{\n            status = 'Player ' + this.state.winner + ' wins! ';\n          }\n        }\n        else{\n          if(computer_side === 'More'){\n            status = 'Computer wins for More! ';\n          }\n          else{\n            status = 'Player ' + this.state.winner + ' wins! ';\n          }\n        } \n      }\n      status += 'Number of groups: ' + groups;\n    }\n\n    var gameboard_render = [];\n    for(let i=0; i<board_size; i++){\n      \n      var content_row = [];\n      for(let j=0; j<board_size; j++){\n\n        content_row.push(this.renderGameboardSquare(i,j));\n      }\n\n      gameboard_render.push(<div className=\"board-row\">{content_row}</div>)\n    }\n\n    return (\n      <div>\n        <div className=\"status\">{status}</div>\n        <div className=\"game-board\">{gameboard_render}</div>\n        \n        <div className=\"colorpicker\">\n          {this.state.colorpieces['Y'] ? this.renderColorpickerSquare('Y') : this.renderColorpickerSquare('C')}\n          {this.state.colorpieces['Y'] ? this.renderColorpickerSquare('Y') : this.renderColorpickerSquare('C')}\n        </div>\n        <div className=\"colorpicker\">\n          {this.state.colorpieces['W'] ? this.renderColorpickerSquare('W') : this.renderColorpickerSquare('C')}\n          {this.state.colorpieces['W'] ? this.renderColorpickerSquare('W') : this.renderColorpickerSquare('C')}\n        </div>\n        <div className=\"colorpicker\">\n          {this.state.colorpieces['R'] ? this.renderColorpickerSquare('R') : this.renderColorpickerSquare('C')}\n          {this.state.colorpieces['R'] ? this.renderColorpickerSquare('R') : this.renderColorpickerSquare('C')}\n        </div>\n        <div className=\"colorpicker\">\n        {this.state.colorpieces['B'] ? this.renderColorpickerSquare('B') : this.renderColorpickerSquare('C')}\n          {this.state.colorpieces['B'] ? this.renderColorpickerSquare('B') : this.renderColorpickerSquare('C')}\n        </div>\n        {this.renderGameModeSwitches()}\n        \n      </div>\n    );\n  }\n}\n\nclass Game extends React.Component {\n  render() {\n    return (\n      <div className=\"game\">\n          <Board />\n      </div>\n    );\n  }\n}\n\n// ========================================\n\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}